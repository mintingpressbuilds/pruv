---
title: "Checkpoints"
description: "Create point-in-time snapshots of chain state and project files. Preview changes and restore to any checkpoint."
---

# Checkpoints

Checkpoints are point-in-time snapshots of chain state (and optionally project files). They enable undo, restore, and preview workflows -- essential when AI agents or automated systems make changes you might need to roll back.

## Overview

A checkpoint captures:
- The full chain state at a specific entry index
- An optional project graph snapshot (file structure, frameworks, services)
- Optional file contents for full restore

```python
from xycore import XYChain
from pruv import CheckpointManager

chain = XYChain(name="my-project")
manager = CheckpointManager(chain, project_dir="./my-project")

# Create a checkpoint
cp = manager.create("before-migration")
print(f"Checkpoint: {cp.id} at entry {cp.entry_index}")
```

## Creating Checkpoints

### Manual Checkpoints

```python
# Checkpoint with graph snapshot only
cp = manager.create("before-refactor")

# Checkpoint with full file contents (for complete restore)
cp = manager.create("before-refactor", include_files=True)
```

### Auto-Checkpoints

Enable automatic checkpointing at regular intervals:

```python
chain = XYChain(
    name="long-running",
    auto_checkpoint=True,
    checkpoint_interval=20,
)

manager = CheckpointManager(chain, project_dir="./my-project")

# Now every 20 entries, a checkpoint is automatically created
for i in range(100):
    chain.append(f"step-{i}", y_state={"step": i})
    # Checkpoints created at entries 20, 40, 60, 80, 100
```

Or via environment variable:

```bash
export PRUV_AUTO_CHECKPOINT=true
```

## Checkpoint Structure

```python
@dataclass
class Checkpoint:
    id: str                              # Unique identifier
    name: str                            # Human-readable name
    chain_id: str                        # Associated chain ID
    entry_index: int                     # Chain entry index at snapshot
    created_at: float                    # Unix timestamp
    chain_snapshot: dict                 # Full chain state as dict
    graph_snapshot: dict | None          # Project graph (optional)
    file_snapshots: dict[str, str] | None  # File contents (optional)
    compressed: bool                     # Whether compressed with zstd
```

## Previewing a Restore

Before restoring, preview what will change:

```python
preview = manager.preview_restore(cp.id)

print(f"Checkpoint: {preview.checkpoint_name}")
print(f"Current entry: {preview.current_entry_index}")
print(f"Target entry: {preview.target_entry_index}")
print(f"Entries to rollback: {preview.entries_to_rollback}")

if preview.diff:
    print(f"File changes: {preview.diff.summary}")
    for change in preview.diff.added:
        print(f"  + {change.path}")
    for change in preview.diff.removed:
        print(f"  - {change.path}")
    for change in preview.diff.modified:
        print(f"  ~ {change.path}")
```

The preview compares the current project state with the checkpoint's graph snapshot, showing you exactly which files changed.

## Restoring a Checkpoint

```python
# Restore to a specific checkpoint
restored_chain = manager.restore(cp.id)
print(f"Restored to entry {cp.entry_index}")
print(f"Chain length now: {restored_chain.length}")
```

Restoring replaces the chain's entries with the checkpoint's snapshot. The chain is then verified to ensure integrity.

### Quick Undo

Restore to the most recent checkpoint:

```python
restored = manager.quick_undo()
if restored:
    print("Restored to last checkpoint")
else:
    print("No checkpoints available")
```

## Listing Checkpoints

```python
for cp_info in manager.list_checkpoints():
    print(f"  {cp_info['id']}: {cp_info['name']} (entry {cp_info['entry_index']})")
```

## Storage

Checkpoints are stored as JSON files in the `.pruv/checkpoints/` directory. When `zstandard` is available, checkpoints are compressed with zstd for efficient storage.

```
.pruv/
  checkpoints/
    a1b2c3d4e5f6.json.zst   # Compressed checkpoint
    b2c3d4e5f6a1.json       # Uncompressed checkpoint
```

## CLI Usage

```bash
# Undo to last checkpoint
pruv undo --chain my-chain-id --last

# Restore to specific checkpoint
pruv undo --chain my-chain-id --to checkpoint-id-here

# Preview without restoring
pruv undo --chain my-chain-id --to checkpoint-id-here --preview
```

## CheckpointManager Configuration

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `chain` | `XYChain` | required | The chain to manage |
| `project_dir` | `str \| Path \| None` | `None` | Project directory for graph snapshots |
| `storage_dir` | `str \| Path` | `".pruv/checkpoints"` | Where to store checkpoint files |
| `compress` | `bool` | `True` | Use zstd compression (if available) |

## Example: AI Agent with Checkpoints

```python
from xycore import XYChain
from pruv import CheckpointManager, xy_wrap

chain = XYChain(name="agent-work", auto_checkpoint=True, checkpoint_interval=10)
manager = CheckpointManager(chain, project_dir="./codebase")

# Create a checkpoint before the agent starts
manager.create("before-agent")

# Wrap and run the agent
@xy_wrap(chain_name="agent-work", scan_dir="./codebase")
async def my_agent(task: str):
    # Agent modifies files...
    return {"files_changed": 5}

result = await my_agent("refactor the auth module")

if not result.verified:
    # Something went wrong -- restore
    manager.quick_undo()
    print("Agent work rolled back")
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Checkpoint/Restore Guide" icon="clock-rotate-left" href="/guides/checkpoint-restore">
    Production patterns for checkpoints and restore workflows.
  </Card>
  <Card title="Wrapping Agents" icon="robot" href="/guides/wrapping-agents">
    Use checkpoints with AI agent wrappers.
  </Card>
</CardGroup>
